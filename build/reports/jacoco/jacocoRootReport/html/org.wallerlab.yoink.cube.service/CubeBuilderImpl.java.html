<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CubeBuilderImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">yoink-core</a> &gt; <a href="index.source.html" class="el_package">org.wallerlab.yoink.cube.service</a> &gt; <span class="el_source">CubeBuilderImpl.java</span></div><h1>CubeBuilderImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.wallerlab.yoink.cube.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.IntStream;

import javax.annotation.Resource;

import org.springframework.stereotype.Service;
import org.wallerlab.yoink.api.model.cube.Cube;
import org.wallerlab.yoink.api.model.molecular.Atom;
import org.wallerlab.yoink.api.model.molecular.Coord;
import org.wallerlab.yoink.api.model.molecular.Molecule;
import org.wallerlab.yoink.api.service.Calculator;
import org.wallerlab.yoink.api.service.Factory;
import org.wallerlab.yoink.api.service.cube.CubeBuilder;
import org.wallerlab.yoink.cube.domain.SimpleCube;
import org.wallerlab.yoink.molecular.domain.SimpleCoord;
import org.wallerlab.yoink.molecular.domain.SimpleCoordFactory;

/**
 * This class is to calculate the grid origin and the number of steps along XYZ
 * axis to construct a cube.
 * 
 * @author Min Zheng
 *
 */
@Service
<span class="fc" id="L47">public class CubeBuilderImpl implements CubeBuilder&lt;Set&lt;Molecule&gt;&gt; {</span>

	@Resource
	private Calculator&lt;Coord, int[], Cube&gt; coordInCubeCalculator;

	@Resource
	private Factory&lt;Coord, double[]&gt; simpleCoordFactory;

	/**
	 * build a cube based on a Set of molecules
	 * 
	 * @param xyzStepSize
	 *            - a double array for step sizes along x/y/z axes
	 * @param molecules
	 *            - a Set of molecules -
	 *            {@link org.wallerlab.yoink.api.model.molecular.Molecule}
	 * 
	 * @return cube -{@link org.wallerlab.yoink.api.model.cube.Cube}
	 */
	public Cube build(double[] xyzStepSize, Set&lt;Molecule&gt; molecules) {
<span class="fc" id="L67">		Cube cube = new SimpleCube(xyzStepSize);</span>
<span class="fc" id="L68">		double[] xyzMinimumOfCube = new double[3];</span>
<span class="fc" id="L69">		double[] xyzMaximumOfCube = new double[3];</span>
		// create three lists for x/y/z coordinates in system
<span class="fc" id="L71">		List&lt;Double&gt; xCoordOfAllMolecules = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L72">		List&lt;Double&gt; yCoordOfAllMolecules = new ArrayList&lt;Double&gt;();</span>
<span class="fc" id="L73">		List&lt;Double&gt; zCoordOfAllMolecules = new ArrayList&lt;Double&gt;();</span>
		// get three lists x/y/z coordinates in system
<span class="fc" id="L75">		getxyzLists(molecules, xCoordOfAllMolecules, yCoordOfAllMolecules,</span>
				zCoordOfAllMolecules);
		// get minimum and maximum of x/y/z coordinates
<span class="fc" id="L78">		getMinMax(xCoordOfAllMolecules, yCoordOfAllMolecules,</span>
				zCoordOfAllMolecules, cube, xyzMinimumOfCube, xyzMaximumOfCube);
		// set the grid origin of cube
<span class="fc" id="L81">		setOrigin(cube, xyzMinimumOfCube);</span>
		// set the number of x/y/z steps
<span class="fc" id="L83">		setNumberOfSteps(cube, xyzMinimumOfCube, xyzMaximumOfCube);</span>
		// set molecules in cube
<span class="fc" id="L85">		cube.setMolecules(molecules);</span>
		// get coordinates for all the grid points in cube
<span class="fc" id="L87">		List&lt;Coord&gt; coordinates = getAllCoordinates(cube);</span>
		// set coordinates for all the grid points in cube
<span class="fc" id="L89">		cube.setCoordinates(coordinates);</span>
<span class="fc" id="L90">		return cube;</span>
	}

	private List&lt;Coord&gt; getAllCoordinates(Cube cube) {
<span class="fc" id="L94">		Coord[] initialValues = new SimpleCoord[cube.getSize()];</span>
<span class="fc" id="L95">		List&lt;Coord&gt; coordinates = Collections.synchronizedList(Arrays</span>
<span class="fc" id="L96">				.asList(initialValues));</span>
<span class="fc" id="L97">		IntStream</span>
<span class="fc" id="L98">				.range(0, cube.getNumberOfXYZSteps()[0])</span>
<span class="fc" id="L99">				.parallel()</span>
<span class="fc" id="L100">				.forEach(</span>
						nXStep -&gt; {
							for (int nYStep = 0; nYStep &lt; cube
									.getNumberOfXYZSteps()[1]; nYStep++) {
								for (int nZStep = 0; nZStep &lt; cube
										.getNumberOfXYZSteps()[2]; nZStep++) {
									// get the coordinate in cube
									int[] xyzCurrentStep = new int[] { nXStep,
											nYStep, nZStep };
									Coord currentCoord = coordInCubeCalculator
											.calculate(xyzCurrentStep, cube);
									// get the index of a grid point in cube
									int indexInCube = nXStep
											* cube.getNumberOfXYZSteps()[1]
											* cube.getNumberOfXYZSteps()[2]
											+ nYStep
											* cube.getNumberOfXYZSteps()[2]
											+ nZStep;
									coordinates.set(indexInCube, currentCoord);
								}
							}
						});
<span class="fc" id="L122">		return coordinates;</span>
	}

	private void setNumberOfSteps(Cube cube, double[] xyzMinimumOfCube,
			double[] xyzMaximumOfCube) {
<span class="fc" id="L127">		int[] numberOfXYZSteps = new int[3];</span>
<span class="fc" id="L128">		numberOfXYZSteps[0] = (int) Math</span>
<span class="fc" id="L129">				.floor(((xyzMaximumOfCube[0] - xyzMinimumOfCube[0]) / cube</span>
<span class="fc" id="L130">						.getXyzStepSize()[0]) + 1);</span>
<span class="fc" id="L131">		numberOfXYZSteps[1] = (int) Math</span>
<span class="fc" id="L132">				.floor(((xyzMaximumOfCube[1] - xyzMinimumOfCube[1]) / cube</span>
<span class="fc" id="L133">						.getXyzStepSize()[1]) + 1);</span>
<span class="fc" id="L134">		numberOfXYZSteps[2] = (int) Math</span>
<span class="fc" id="L135">				.floor(((xyzMaximumOfCube[2] - xyzMinimumOfCube[2]) / cube</span>
<span class="fc" id="L136">						.getXyzStepSize()[2]) + 1);</span>
<span class="fc" id="L137">		cube.setNumberOfXYZSteps(numberOfXYZSteps);</span>
<span class="fc" id="L138">		cube.setSize(numberOfXYZSteps[0] * numberOfXYZSteps[1]</span>
				* numberOfXYZSteps[2]);

<span class="fc" id="L141">	}</span>

	private void setOrigin(Cube cube, double[] xyzMinimumOfCube) {
		// Coord gridOrigin = new SimpleCoord(xyzMinimumOfCube[0],
		// xyzMinimumOfCube[1], xyzMinimumOfCube[2]);
<span class="fc" id="L146">		Coord gridOrigin = simpleCoordFactory</span>
<span class="fc" id="L147">				.create(new double[] { xyzMinimumOfCube[0],</span>
						xyzMinimumOfCube[1], xyzMinimumOfCube[2] });
<span class="fc" id="L149">		cube.setGridOrigin(gridOrigin);</span>
<span class="fc" id="L150">	}</span>

	private void getMinMax(List&lt;Double&gt; xCoordOfAllMolecules,
			List&lt;Double&gt; yCoordOfAllMolecules,
			List&lt;Double&gt; zCoordOfAllMolecules, Cube cube,
			double[] xyzMinimumOfCube, double[] xyzMaximumOfCube) {
<span class="fc" id="L156">		double xMinimumOfCube = Collections.min(xCoordOfAllMolecules);</span>
<span class="fc" id="L157">		double yMinimumOfCube = Collections.min(yCoordOfAllMolecules);</span>
<span class="fc" id="L158">		double zMinimumOfCube = Collections.min(zCoordOfAllMolecules);</span>
<span class="fc" id="L159">		double xMaximumOfCube = Collections.max(xCoordOfAllMolecules);</span>
<span class="fc" id="L160">		double yMaximumOfCube = Collections.max(yCoordOfAllMolecules);</span>
<span class="fc" id="L161">		double zMaximumOfCube = Collections.max(zCoordOfAllMolecules);</span>
		// build a larger cube to write cube files
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">		if (cube.getDensityTypes().size() != 0) {</span>
<span class="nc" id="L164">			xMinimumOfCube -= 2;</span>
<span class="nc" id="L165">			yMinimumOfCube -= 2;</span>
<span class="nc" id="L166">			zMinimumOfCube -= 2;</span>
<span class="nc" id="L167">			xMaximumOfCube += 2;</span>
<span class="nc" id="L168">			yMaximumOfCube += 2;</span>
<span class="nc" id="L169">			zMaximumOfCube += 2;</span>
		}
<span class="fc" id="L171">		xyzMinimumOfCube[0] = xMinimumOfCube;</span>
<span class="fc" id="L172">		xyzMinimumOfCube[1] = yMinimumOfCube;</span>
<span class="fc" id="L173">		xyzMinimumOfCube[2] = zMinimumOfCube;</span>
<span class="fc" id="L174">		xyzMaximumOfCube[0] = xMaximumOfCube;</span>
<span class="fc" id="L175">		xyzMaximumOfCube[1] = yMaximumOfCube;</span>
<span class="fc" id="L176">		xyzMaximumOfCube[2] = zMaximumOfCube;</span>
<span class="fc" id="L177">	}</span>

	private void getxyzLists(Set&lt;Molecule&gt; molecules,
			List&lt;Double&gt; xCoordOfAllAtoms, List&lt;Double&gt; yCoordOfAllAtoms,
			List&lt;Double&gt; zCoordOfAllAtoms) {
<span class="fc bfc" id="L182" title="All 2 branches covered.">		for (Molecule molecule : molecules) {</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">			for (Atom atom : molecule.getAtoms()) {</span>
<span class="fc" id="L184">				xCoordOfAllAtoms.add(atom.getX3());</span>
<span class="fc" id="L185">				yCoordOfAllAtoms.add(atom.getY3());</span>
<span class="fc" id="L186">				zCoordOfAllAtoms.add(atom.getZ3());</span>
<span class="fc" id="L187">			}</span>
<span class="fc" id="L188">		}</span>
<span class="fc" id="L189">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>